/*
 * generated by Xtext
 */
package edu.upb.compilacion.validation

import edu.upb.compilacion.HugeException
import edu.upb.compilacion.MismatchedTypeException
import edu.upb.compilacion.TypeInferrer
import edu.upb.compilacion.listaCompiler.Evaluation
import edu.upb.compilacion.listaCompiler.FunctionDefinition
import edu.upb.compilacion.listaCompiler.Lista
import edu.upb.compilacion.listaCompiler.ListaCompilerPackage
import edu.upb.compilacion.listaCompiler.PDFunction
import edu.upb.compilacion.listaCompiler.PreDefFunctionCall
import edu.upb.compilacion.listaCompiler.UserDefFunctionCall
import org.eclipse.xtext.validation.Check

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ListaCompilerValidator extends AbstractListaCompilerValidator {
	
	private static val WRONG_PARAMETERS_NUMBER = "wrongParametersNumber";
	private static val WRONG_EXPRESSION_TYPE = "wrongExpressionType";
	private static val INVALID_FUNCTION_DECLARATION = "invalidFunctionDeclaration"
	private static val UNUSED_VARIABLE = "unusedVariable";
	
	/**
	 * Checks that a function definition doesn't have the same name as a predefined function.
	 */
	@Check
	def checkFunctionDefinitionsPreDefNames(Lista lista) {
		for (fd : lista.definitions) {
			for (i : 0 ..< PDFunction.values.length) {
				if (PDFunction.get(i).getName.equals(fd.name)) {
					error("The method '" + fd.name + "' is a predefined Lista method.",
						ListaCompilerPackage.Literals.LISTA__DEFINITIONS,
						ListaCompilerValidator.INVALID_FUNCTION_DECLARATION
						)
				}
			}
		}
	}
	
	/**
	 * Checks that a function definition doesn't have the same name as an already defined function.
	 */
	@Check
	def checkFunctionDefinitionsNames(Lista lista) {
		val definitions = lista.definitions; 
		var curName = ""
		for (cur : 1 ..< definitions.length) {
			curName = definitions.get(cur).name;
			for (i : 0 ..< cur) {
				if (definitions.get(i).name.equals(curName)) {
					error("The method named '" + curName + "' can only be declared once.",
					ListaCompilerPackage.Literals.LISTA__DEFINITIONS,
					ListaCompilerValidator.INVALID_FUNCTION_DECLARATION
					)
				}
			}
		}
	}
	
	/**
	 * Checks that a parameters isn't declared more than one time.
	 */
	@Check
	def checkFunctionDefinitionsParameters(FunctionDefinition fd) {
		var curName = ""
		for (cur : 1 ..< fd.params.length) {
			curName = TypeInferrer.getVariable(fd.params.get(cur));
			for (i : 0 ..< cur) {
				if (TypeInferrer.getVariable(fd.params.get(i)).equals(curName)) {
					error("The parameter '" + curName + "' can only be declared once.",
					ListaCompilerPackage.Literals.FUNCTION_DEFINITION__PARAMS,
					ListaCompilerValidator.INVALID_FUNCTION_DECLARATION
					)
				}
			}
		}
	}

	/**
	 * Checks the number of parameters for a user defined function.
	 */
	@Check
	def checkUserDefParametersNumber(UserDefFunctionCall fcall) {
		val params = fcall.function.params.length;
		if (fcall.args.length != params) {
			error('Wrong number of parameters, should be ' + params,
				ListaCompilerPackage.Literals.FUNCTION_CALL__ARGS,
				WRONG_PARAMETERS_NUMBER
			)
		}
	}
	
	/**
	 * Checks the number of parameters for a predefined function.
	 */
	@Check
	def checkPreDefParametersNumber(PreDefFunctionCall fcall) {
		val function = fcall.function;
		var params = 0;
		
		switch (function) {
			case PDFunction.SHOW,
			case PDFunction.LENGTH,
			case PDFunction.CAR,
			case PDFunction.CDR,
			case PDFunction.IS_EMPTY:
				params = 1
			case PDFunction.CONS:
				params = 2
			default:
				error("Undeclared function " + function.literal,
					ListaCompilerPackage.Literals.FUNCTION_CALL__ARGS,
					INVALID_FUNCTION_DECLARATION)
		}
		
		if (fcall.args.length != params) {
			error('Wrong number of parameters, should be ' + 1,
			ListaCompilerPackage.Literals.FUNCTION_CALL__ARGS,
			WRONG_PARAMETERS_NUMBER);
		}
	}
	
	/**
	 * Infers and checks the return expression type of a FunctionDefinition, verifies that it
	 * satisfy all the expression checks inside TypeInferrer. The infer is done twice because
	 * in the first one there is a chance that all the variables doesn't infer correctly
	 * because they may need other variables' types as a pointer to infer it's type.
	 * If there is an exception, shows an error with the exception message.
	 */
	@Check
	def checkFunctionDefinitionType(FunctionDefinition fd) {
		TypeInferrer.removeFunctionInfo(fd);
		TypeInferrer.inferDataType(fd);
		TypeInferrer.inferDataType(fd);
		checkFunctionDefinitionParams(fd);
		try {
			TypeInferrer.checkDataType(fd.^return);
		} catch (MismatchedTypeException ex) {
			error(ex.message,
			ListaCompilerPackage.Literals.FUNCTION_DEFINITION__RETURN,
			WRONG_EXPRESSION_TYPE);
		} catch (HugeException ex) {
			error(ex.message,
			ListaCompilerPackage.Literals.FUNCTION_DEFINITION__RETURN,
			WRONG_EXPRESSION_TYPE);
		}
		TypeInferrer.resetCurrentFunction();
	}
	
	/**
	 * Checks the usage of a FunctionDefinition parameters, if there is an unused variable,
	 * it shows a warning, if there is a variable that it's not declared it shows an error.
	 */
	def checkFunctionDefinitionParams(FunctionDefinition fd) {
		for (param : fd.params) {
			if (!TypeInferrer.functionParams.get(fd.name).containsKey(TypeInferrer.getVariable(param))) {
				warning("Variable " + TypeInferrer.getVariable(param) + " is not used.",
					ListaCompilerPackage.Literals.FUNCTION_DEFINITION__PARAMS,
					UNUSED_VARIABLE);
			}
		}
		
		for (param : TypeInferrer.functionParams.get(fd.name).keySet()) {
			if (!fdContainsParam(fd,param)) {
				error("Variable " + param + " is not declared, should be added to the function's parameters.",
					ListaCompilerPackage.Literals.FUNCTION_DEFINITION__PARAMS,
					INVALID_FUNCTION_DECLARATION);
			}
		}
	}
	
	/**
	 * Verifies that a FunctionDefinition contains a given parameter.
	 */
	def fdContainsParam(FunctionDefinition fd, String name) {
		for (param : fd.params) {
			if (TypeInferrer.getVariable(param).equals(name)) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Checks an Evaluation return expression type and verifies that it
	 * satisfy all the expression checks inside TypeInferrer.
	 */
	@Check
	def checkFunctionEvaluationType(Evaluation eval) {
		try {
			TypeInferrer.checkDataType(eval.^return);
		} catch (MismatchedTypeException ex) {
			error(ex.message,
			ListaCompilerPackage.Literals.EVALUATION__RETURN,
			WRONG_EXPRESSION_TYPE);
		} catch (HugeException ex) {
			error(ex.message,
			ListaCompilerPackage.Literals.EVALUATION__RETURN,
			WRONG_EXPRESSION_TYPE);
		}
	}
}
