/*
 * generated by Xtext
 */
package edu.upb.compilacion.validation

import edu.upb.compilacion.HugeException
import edu.upb.compilacion.MismatchedTypeException
import edu.upb.compilacion.listaCompiler.Expression
import edu.upb.compilacion.listaCompiler.FirstLevelExp
import edu.upb.compilacion.listaCompiler.FirstLevelOp
import edu.upb.compilacion.listaCompiler.FourthLevelExp
import edu.upb.compilacion.listaCompiler.FunctionCall
import edu.upb.compilacion.listaCompiler.FunctionDefinition
import edu.upb.compilacion.listaCompiler.IfControlFlow
import edu.upb.compilacion.listaCompiler.List
import edu.upb.compilacion.listaCompiler.Lista
import edu.upb.compilacion.listaCompiler.ListaCompilerPackage
import edu.upb.compilacion.listaCompiler.MyBool
import edu.upb.compilacion.listaCompiler.MyInteger
import edu.upb.compilacion.listaCompiler.MyString
import edu.upb.compilacion.listaCompiler.MyVariable
import edu.upb.compilacion.listaCompiler.PDFunction
import edu.upb.compilacion.listaCompiler.PreDefFunctionCall
import edu.upb.compilacion.listaCompiler.SecondLevelExp
import edu.upb.compilacion.listaCompiler.SecondLevelOp
import edu.upb.compilacion.listaCompiler.Term
import edu.upb.compilacion.listaCompiler.ThirdLevelExp
import edu.upb.compilacion.listaCompiler.ThirdLevelOp
import edu.upb.compilacion.listaCompiler.UserDefFunctionCall
import java.util.HashMap
import org.eclipse.xtext.validation.Check

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ListaCompilerValidator extends AbstractListaCompilerValidator {
	
	enum DataType {
		INT, STRING, BOOL, LIST, VAR, GLOBAL
	}
	
	public static val WRONG_PARAMETERS_NUMBER = "wrongParametersNumber";
	public static val WRONG_EXPRESSION_TYPE = "wrongExpressionType";
	public static val INVALID_FUNCTION_DECLARATION = "invalidFunctionDeclaration"
	
	private var functionDefs = new HashMap();
	
	@Check
	def checkFunctionDefinitionsPreDefNames(Lista lista) {
		for (fd : lista.definitions) {
			for (i : 0 ..< PDFunction.values.length) {
				if (PDFunction.get(i).getName.equals(fd.name)) {
					error("The method '" + fd.name + "' is a predefined Lista method.",
						ListaCompilerPackage.Literals.LISTA__DEFINITIONS,
						ListaCompilerValidator.INVALID_FUNCTION_DECLARATION
						)
				}
			}
		}
	}
	
	@Check
	def checkFunctionDefinitionsNames(Lista lista) {
		val definitions = lista.definitions; 
		var curName = ""
		for (cur : 1 ..< definitions.length) {
			curName = definitions.get(cur).name;
			for (i : 0 ..< cur) {
				if (definitions.get(i).name.equals(curName)) {
					error("The method named '" + curName + "' can only be declared once.",
					ListaCompilerPackage.Literals.LISTA__DEFINITIONS,
					ListaCompilerValidator.INVALID_FUNCTION_DECLARATION
					)
				}
			}
		}
	}
	
	@Check
	def checkFunctionDefinitionsParameters(FunctionDefinition fd) {
		var curName = ""
		for (cur : 1 ..< fd.params.length) {
			curName = fd.params.get(cur);
			for (i : 0 ..< cur) {
				if (fd.params.get(i).equals(curName)) {
					error("The parameter '" + curName + "' can only be declared once.",
					ListaCompilerPackage.Literals.FUNCTION_DEFINITION__PARAMS,
					ListaCompilerValidator.INVALID_FUNCTION_DECLARATION
					)
				}
			}
		}
	}

	@Check
	def checkUserDefParametersNumber(UserDefFunctionCall fcall) {
		val params = fcall.function.params.length;
		if (fcall.args.length != params) {
			error('Wrong number of parameters, should be ' + params,
				ListaCompilerPackage.Literals.FUNCTION_CALL__ARGS,
				WRONG_PARAMETERS_NUMBER
			)
		}
	}
	
	@Check
	def checkPreDefParametersNumber(PreDefFunctionCall fcall) {
		val function = fcall.function;
		var params = 0;
		
		switch (function) {
			case PDFunction.SHOW,
			case PDFunction.LENGTH,
			case PDFunction.CAR,
			case PDFunction.CDR,
			case PDFunction.IS_EMPTY:
				params = 1
			case PDFunction.CONS:
				params = 2
			default:
				params = 0
		}
		
		if (fcall.args.length != params) {
			error('Wrong number of parameters, should be ' + 1,
			ListaCompilerPackage.Literals.FUNCTION_CALL__ARGS,
			WRONG_PARAMETERS_NUMBER);
		}
	}
	
	@Check
	def checkExpressionType(Expression exp) {
		try {
			exp.getDataType;
		} catch (MismatchedTypeException ex) {
			error(ex.message,
			ListaCompilerPackage.Literals.EXPRESSION__EXP,
			WRONG_EXPRESSION_TYPE);
		}
	}
	
	@Check
	def checkIfControlFlowType(IfControlFlow ifCF) {
		try {
			val cond = ifCF.cond.getDataType;
			val iftrue = ifCF.iftrue.getDataType;
			val iffalse = ifCF.iffalse.getDataType;
			if (!cond.equals(DataType.BOOL)) {
				error("Condition should be type BOOL.",
				ListaCompilerPackage.Literals.IF_CONTROL_FLOW__COND,
				WRONG_EXPRESSION_TYPE);
			}
			if (!iftrue.equals(iffalse)) {
				error("Both statements should return the same type.",
				ListaCompilerPackage.Literals.IF_CONTROL_FLOW__IFTRUE,
				WRONG_EXPRESSION_TYPE);
			}
		} catch (MismatchedTypeException ex) {
			error(ex.message,
			ListaCompilerPackage.Literals.EXPRESSION__EXP,
			WRONG_EXPRESSION_TYPE);
		}
	}
	
	def getDataType(Expression exp) {
		return exp.exp.getDataType;
	}
	
	def getDataType(FirstLevelExp exp) {
		val first = (exp.args.get(0) as SecondLevelExp).getDataType;
		val op = exp.op;
		if (exp.args.length > 1) {
			var expected = DataType.GLOBAL;
			switch (op) {
				case FirstLevelOp.AND,
				case FirstLevelOp.OR:
					expected = DataType.BOOL
				default:
					expected = DataType.GLOBAL				
			}
			if (first.equals(expected) &&
				(exp.args.get(1) as FirstLevelExp).getDataType.equals(expected)) {
				return expected;
			} else {
				throw new MismatchedTypeException("Mismatched data types for operator " +
					 op.getName() + ", arguments should be " + expected.toString() + ".");
			}
		} else {
			return first;
		}
	}
	
	def getDataType(SecondLevelExp exp) {
		val first = (exp.args.get(0) as ThirdLevelExp).getDataType;
		val op = exp.op;
		if (exp.args.length > 1) {
			var expected = DataType.GLOBAL;
			switch (op) {
				case SecondLevelOp.GT,
				case SecondLevelOp.LT:
					expected = DataType.INT
				case SecondLevelOp.EQ:
					return exp.compareEquals
				default:
					expected = DataType.GLOBAL				
			}
			if (first.equals(expected) &&
				(exp.args.get(1) as SecondLevelExp).getDataType.equals(expected)) {
				return expected;
			} else {
				throw new MismatchedTypeException("Mismatched data types for operator " +
					 op.getName() + ", arguments should be " + expected.toString() + ".");
			}
		} else {
			return first;
		}
	}
	
	def getDataType(ThirdLevelExp exp) {
		val first = (exp.args.get(0) as FourthLevelExp).getDataType;
		val op = exp.op;
		if (exp.args.length > 1) {
			var expected = DataType.GLOBAL;
			switch (op) {
				case ThirdLevelOp.PLUS,
				case ThirdLevelOp.MINUS:
					expected = DataType.INT
				case ThirdLevelOp.CONCAT:
					expected = DataType.STRING
				default:
					expected = DataType.GLOBAL				
			}
			if (first.equals(expected) &&
				(exp.args.get(1) as ThirdLevelExp).getDataType.equals(expected)) {
				return expected;					
			} else {
				throw new MismatchedTypeException("Mismatched data types for operator " +
					 op.getName() + ", arguments should be " + expected.toString() + ".");
			}
		} else {
			return first;
		}
	}
	
	def getDataType(FourthLevelExp exp) {
		val first = (exp.args.get(0) as Term).getDataType;
		if (exp.args.length > 1) {
			if (first.equals(DataType.INT) &&
				(exp.args.get(1) as FourthLevelExp).getDataType.equals(DataType.INT)) {
				return DataType.INT;					
			} else {
				throw new MismatchedTypeException("Mismatched data types for operator " + exp.op.getName() + ", arguments should be INT.");
			}
		} else {
			return first;
		}
	}
	
	def getDataType(Term term) {
		if (term instanceof MyInteger) {
			return DataType.INT;
		} else if (term instanceof MyString) {
			return DataType.STRING;
		} else if (term instanceof MyBool) {
			return DataType.BOOL;
		} else if (term instanceof List) {
			return DataType.LIST;
		} else if (term instanceof MyVariable) {
			return DataType.VAR;
		} else if (term instanceof FunctionCall) {
			return (term as FunctionCall).getDataType;
		} else if (term instanceof IfControlFlow) {
			return (term as IfControlFlow).getDataType;
		}
	}
	
	def getDataType(FunctionCall fcall) {
		if (fcall instanceof PreDefFunctionCall) {
			return (fcall as PreDefFunctionCall).getDataType;
		} else if (fcall instanceof UserDefFunctionCall) {
			return (fcall as UserDefFunctionCall).getDataType;
		}
	}
	
	def getDataType(PreDefFunctionCall fcall) {
		switch (fcall.function) {
			case PDFunction.SHOW:
				return DataType.STRING
			case PDFunction.LENGTH,
			case PDFunction.CAR:
				return DataType.INT
			case PDFunction.CDR,
			case PDFunction.CONS:
				return DataType.LIST
			case PDFunction.IS_EMPTY:
				return DataType.BOOL
			default:
				throw new HugeException(fcall.function + " method is not predefined.")
		}
	}
	
	def getDataType(UserDefFunctionCall fcall) {
		return fcall.function.^return.getDataType;
	}
	
	def getDataType(IfControlFlow ifCF) {
		return ifCF.iftrue.getDataType;
	}
	
	def compareEquals(SecondLevelExp exp) {
		val first = (exp.args.get(0) as ThirdLevelExp).getDataType;
		val second = (exp.args.get(1) as SecondLevelExp).getDataType;
		if (first.equals(second)) {
			return first;
		}
		throw new MismatchedTypeException("The two arguments being compared with " + SecondLevelOp.EQ.getName() + " should have the same type.");
	}
	
	/*def inferVariablesTypes(ThirdLevelExp exp) {
		var vars = new HashMap();
		val first = exp.args.get(0) as FourthLevelExp;
		val firstType = first.getDataType;
		if (exp.args.length > 1) {
			val second = exp.args.get(1) as ThirdLevelExp;
			val secondType = second.getDataType;
			if (firstType.equals(DataType.VAR)) {
				vars.put((first as MyVariable).^var, DataType.INT);
			}
			if (secondType.equals(DataType.VAR)) {
				vars.put((second as MyVariable).^var, DataType.INT);
			}
		} else {
			if (firstType.equals(DataType.VAR)) {
				vars.put((first as MyVariable).^var, DataType.VAR);
			}
		}
		return vars;
	}*/
	
	/*def inferVariablesTypes(FourthLevelExp exp) {
		var vars = new HashMap();
		val first = exp.args.get(0) as Term;
		val firstType = first.getDataType;
		if (exp.args.length > 1) {
			val second = exp.args.get(1) as FourthLevelExp;
			val secondType = second.getDataType;
			if (firstType.equals(DataType.VAR)) {
				vars.put((first as MyVariable).^var, DataType.INT);
			}
			if (secondType.equals(DataType.VAR)) {
				vars.put((second as MyVariable).^var, DataType.INT);
			}
		} else {
			if (firstType.equals(DataType.VAR)) {
				vars.put((first as MyVariable).^var, DataType.VAR);
			}
		}
		return vars;
	}*/
}
